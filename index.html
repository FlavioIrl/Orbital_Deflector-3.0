<!DOCTYPE html>
<html lang="pt-PT">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Deflector 3.0 - Balanced & Polished</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #hud {
            display: none;
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }

        h1 {
            margin: 0;
            font-size: 20px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }


        #statusBars {
            margin-top: 10px;
        }

        .bar-label {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .bar-bg {
            width: 250px;
            height: 10px;
            background: #222;
            border: 1px solid #444;
            position: relative;
            border-radius: 5px;
            overflow: hidden;
        }

        #hpBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #ff5588);
            transition: width 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #xpBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            transition: width 0.3s;
        }

        #mainMenu,
        #levelUpMenu,
        #pauseMenu,
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
        }

        #mainMenu {
            background: radial-gradient(circle, #111 0%, #000 100%);
        }

        #levelUpMenu,
        #pauseMenu,
        #gameOverScreen {
            display: none;
        }

        .card-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .card {
            background: #111;
            border: 2px solid #00ffff;
            width: 220px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
        }

        .card:hover {
            transform: scale(1.05);
            background: #1a1a1a;
            border-color: #ffaa00;
        }

        .menu-btn {
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            margin: 10px;
            transition: 0.3s;
            min-width: 200px;
        }

        .menu-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }

        .btn-test {
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .btn-test:hover {
            background: #ffaa00;
            box-shadow: 0 0 20px #ffaa00;
        }

        #gameOverScreen {
            background: rgba(20, 0, 0, 0.95);
        }

        #pauseUpgradesContainer {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .upgrade-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #00ffff;
            padding: 10px;
            border-radius: 8px;
            width: 120px;
            text-align: center;
        }

        .upgrade-card img {
            width: 40px;
            height: 40px;
            margin: 0 auto 5px;
            display: block;
            image-rendering: pixelated;
            /* Se for pixel art */
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: #666;
            display: none;
        }

        /* Barra de Upgrades no Topo durante o jogo */
        #upgradeHUD {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 6px 14px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            pointer-events: none;
            z-index: 5;
        }

        .upgrade-icon {
            width: 28px;
            height: 28px;
            position: relative;
            border-radius: 4px;
            background: rgba(0, 255, 255, 0.12);
            border: 1px solid rgba(0, 255, 255, 0.6);
            overflow: hidden;
        }

        .upgrade-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .upgrade-count {
            position: absolute;
            bottom: 1px;
            right: 2px;
            font-size: 11px;
            font-weight: bold;
            color: #ffaa00;
        }

        /* Lista de Upgrades no Menu de Pausa */
        #pauseUpgrades {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 80%;
        }

        /* .upgrade-card img {
            width: 50px;
            height: 50px;
            display: block;
            margin: 0 auto 10px;
            object-fit: contain;
        } */

        .pause-upgrade-count {
            display: block;
            font-size: 16px;
            font-weight: bold;
            color: #ffaa00;
            margin-top: 5px;
        }

        #hud,
        #upgradeHUD,
        #pauseMenu,
        #levelUpMenu,
        #gameOverScreen {
            position: absolute;
            z-index: 10;
        }
    </style>
</head>

<body>

    <div id="mainMenu">
        <h1 style="font-size: 48px; margin-bottom: 30px;">Orbital Deflector</h1>
        <p style="color: #666; margin-bottom: 40px;">SISTEMA FOI PRO CARALHO</p>
        <button class="menu-btn" onclick="startGame('solo')">Modo Solo</button>
        <button class="menu-btn btn-test" onclick="startGame('test')">Modo de Teste</button>
    </div>
    <div id="hud">
        <h1>Orbital Deflector <span id="modeDisplay" style="font-size:0.6em"></span></h1>
        <div id="statusBars">
            <div class="bar-label">Integridade do Núcleo</div>
            <div class="bar-bg">
                <div id="hpBar"></div>
            </div>
            <div class="bar-label">Sincronização de Dados (XP)</div>
            <div class="bar-bg">
                <div id="xpBar"></div>
            </div>
        </div>
        <p style="font-size: 12px; color: #666; margin-top: 10px;">Score: <span id="scoreVal">0</span> | Nível: <span
                id="levelVal">1</span></p>
    </div>
    <div id="upgradeHUD"></div>
    <div id="bossHUD"
        style="display: none; position: absolute; top: 60px; left: 50%; transform: translateX(-50%); text-align: center; z-index: 10;">
        <div
            style="color: #ff0055; font-weight: bold; text-transform: uppercase; letter-spacing: 3px; margin-bottom: 5px; text-shadow: 0 0 10px #ff0055;">
            Sentinela de Combate</div>
        <div class="bar-bg"
            style="width: 500px; height: 15px; border-color: #ff0055; box-shadow: 0 0 15px rgba(255, 0, 85, 0.3);">
            <div id="bossHpBar"
                style="width: 100%; height: 100%; background: linear-gradient(90deg, #ff0055, #990022); transition: width 0.1s;">
            </div>
        </div>
    </div>


    <div class="controls-hint" id="hintBox">
        WASD: Mover | Mouse: Mirar | P: Pausa
    </div>

    <div id="levelUpMenu">
        <h2 style="color: #ffaa00;">UPGRADE DISPONÍVEL</h2>
        <div class="card-container" id="cardsBox"></div>
    </div>

    <div id="pauseMenu">
        <h2 style="color: #00ffff;">SISTEMA PAUSADO</h2>
        <p style="color: #666;">UPGRADES COLETADOS:</p>
        <div id="pauseUpgradesContainer"></div>
        <button class="menu-btn" onclick="togglePause()">Retomar</button>

    </div>

    <div id="gameOverScreen">
        <h2 style="color: #ff0055; font-size: 40px;">SISTEMA CRITICAMENTE DANIFICADO</h2>
        <p>Pontuação Final: <span id="finalScore">0</span></p>
        <button class="menu-btn" onclick="location.reload()">Reiniciar Terminal</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            generateBackground();
        }
        window.onresize = resize;

        const spriteImg = new Image();
        spriteImg.src = 'sprites/graficos.png';

        const shipSprite = { sx: 404, sy: 392, sw: 118, sh: 160 };
        const xpSpriteDef = { sx: 409, sy: 591, sw: 10, sh: 10 };
        const bulletSmall = { sx: 856, sy: 389, sw: 10, sh: 19 };
        const bulletMedium = { sx: 834, sy: 383, sw: 4, sh: 10 };
        const bulletLarge = { sx: 237, sy: 92, sw: 22, sh: 50 };

        // const enemySpriteDef = { sx: 542, sy: 170, sw: 28, sh: 28 };
        const enemySprites = {
            normal: { sx: 542, sy: 170, sw: 28, sh: 28 },
            elite: { sx: 297, sy: 521, sw: 93, sh: 93 },
            tank: { sx: 554, sy: 25, sw: 92, sh: 92 },
            boss: { sx: 684, sy: 279, sw: 119, sh: 74 }
        };

        const starSprites = [
            { sx: 129, sy: 18, sw: 55, sh: 42 },
            { sx: 126, sy: 345, sw: 32, sh: 32 },
            { sx: 100, sy: 188, sw: 21, sh: 20 },
        ];


        // No topo do script, junto com as outras variáveis de estado
        let explosionAnimations = [];

        // Defina as coordenadas dos frames da sua explosão (exemplo de 4 frames)
        // Ajuste sx e sy conforme a posição real no seu 'graficos.png'
        const explosionFrames = [
            { sx: 239, sy: 139, sw: 98, sh: 81 },
            { sx: 235, sy: 408, sw: 98, sh: 81 },
            { sx: 4, sy: 559, sw: 98, sh: 81 },
            { sx: 143, sy: 434, sw: 98, sh: 81 },
        ];

        let spriteLoaded = false;
        spriteImg.onload = () => { spriteLoaded = true; generateBackground(); };

        let bgPattern;

        function generateBackground() {
            // Esta função agora é vazia porque o fundo é gerado no drawBackground()
            console.log("Sistema de fundo infinito ativo.");
        }

        // --- GAME STATE ---
        let gameState = 'menu';
        let isTestMode = false;
        let score = 0;
        let level = 1;
        let xp = 0;
        let nextLevelXp = 100;
        let hp = 100;

        const camera = { x: 0, y: 0, lerp: 0.1 };

        const activeUpgrades = {
            laser: 0,
            plasma: 0,
            speed: 0,
            magnet: 0,
            fireRate: 0,
            damage: 0
        };

        const upgrades = {
            magnetRange: 160,
            plasmaCannon: false,
            laserGun: false,
            plasmaCd: 0,
            moveSpeed: 4.5,
            fireRate: 18,
            damage: 1,
            plasmaDamageMult: 4.5,
            laserDamageMult: 0.35,
            laserFireRate: 12,
        };

        const p1 = {
            x: 0,
            y: 0,
            radius: 25,
            angle: 0,
            cd: 0,
            laserCd: 0
        };

        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let explosions = [];
        let particles = [];
        let loot = [];

        // SISTEMA DE HORDA 

        let waveEnemyHP = 5;

        let wave = 1;
        let enemiesToSpawn = 0;
        let waveInProgress = false;
        let spawnCooldown = 0;

        let waveBanner = {
            active: false,
            timer: 0,
            duration: 120, // frames (~2s)
            text: ''
        };


        const MAX_PARTICLES = 400;
        // const MAX_ENEMIES = 85;

        const keys = {};
        const mouse = { x: 0, y: 0 };

        // let pauseLock = false;

        window.onkeydown = e => {
            const key = e.key.toLowerCase();

            if (keys[key]) return; // evita repetição
            keys[key] = true;

            if ((key === 'p' || key === 'escape') && gameState === 'playing') {
                togglePause();
            }
        };

        window.onkeyup = e => {
            const key = e.key.toLowerCase();
            keys[key] = false;
        };

        window.onmousemove = e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        };

        // --- FUNÇÃO PARA SINCRONIZAR O HUD ---
        function updateHUD() {
            document.getElementById('hpBar').style.width = Math.max(0, hp) + '%';
            document.getElementById('xpBar').style.width = Math.min(100, (xp / nextLevelXp) * 100) + '%';
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('levelVal').innerText = level;

            document.getElementById('hpBar').style.width = Math.max(0, hp) + '%';
            document.getElementById('xpBar').style.width = Math.min(100, (xp / nextLevelXp) * 100) + '%';
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('levelVal').innerText = level;

            // --- NOVA LÓGICA DO BOSS NA UPDATEHUD ---
            const bossHud = document.getElementById('bossHUD');
            // Procuramos o objeto que tem o tipo 'boss'
            const bossEntity = enemies.find(e => e.type === 'boss');

            if (bossAlive && bossEntity) {
                bossHud.style.display = 'block';

                // Calculamos a porcentagem: (Vida Atual / Vida Máxima) * 100
                const pct = (bossEntity.hp / bossEntity.maxHp) * 100;

                // Atualizamos a largura da barra
                document.getElementById('bossHpBar').style.width = Math.max(0, pct) + '%';

            } else {
                // Se o boss morreu ou não existe, esconde a HUD
                bossHud.style.display = 'none';
            }
        }

        function startGame(mode) {
            isTestMode = (mode === 'test');
            gameState = 'playing';

            initStars();



            if (isTestMode) {
                upgrades.plasmaCannon = true;
                upgrades.laserGun = true;
                upgrades.damage = 10;
                upgrades.fireRate = 4;
                upgrades.laserFireRate = 2;
            }

            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('hintBox').style.display = 'block';
            document.getElementById('modeDisplay').innerText = isTestMode ? 'TESTE' : 'SOLO';

            wave = 1;
            startWave();
            // updateHUD();
            resize();
            renderUpgradeHUD();
            gameLoop();
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                renderPauseUpgrades(); // Atualiza a lista com quantidades no pause
                renderUpgradeHUD();
                document.getElementById('pauseMenu').style.display = 'flex';
            } else if (gameState === 'paused') {
                gameState = 'playing';
                document.getElementById('pauseMenu').style.display = 'none';
                // gameLoop();

            }
        }

        let starLayers = [];

        function initStars() {
            starLayers = [];
            // Criamos 3 camadas: Longe (lenta), Média, Perto (rápida)
            for (let l = 0; l < 3; l++) {
                let layer = {
                    speed: (l + 1) * 0.2, // Velocidade diferente para cada camada
                    stars: []
                };
                // Gerar 100 estrelas procedurais por camada
                for (let i = 0; i < 100; i++) {
                    layer.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * (l + 1) * 1.2,
                        opacity: Math.random() * 0.5 + 0.3,
                        sprite: Math.random() > 0.8 ? starSprites[Math.floor(Math.random() * starSprites.length)] : null
                    });
                }
                starLayers.push(layer);
            }
        }

        function createParticle(x, y, color, size, vx, vy, life) {
            if (particles.length > MAX_PARTICLES) return;
            particles.push({ x, y, color, size, vx, vy, life, maxLife: life });
        }

        function createExplosion(x, y, radius, damage) {
            explosions.push({ x, y, r: 0, maxR: radius, alpha: 1 });
            for (let i = 0; i < 15; i++) {
                const ang = Math.random() * Math.PI * 2;
                const spd = Math.random() * 5 + 2;
                createParticle(x, y, '#ffaa00', Math.random() * 4, Math.cos(ang) * spd, Math.sin(ang) * spd, 25);
            }
            enemies.forEach(e => {
                const dx = e.x - x;
                const dy = e.y - y;
                const distSq = dx * dx + dy * dy;
                const radSum = radius + e.r;
                if (distSq < radSum * radSum) {
                    e.hp -= damage;
                    e.hitTimer = 8;
                    const ang = Math.atan2(dy, dx);
                    e.x += Math.cos(ang) * 25;
                    e.y += Math.sin(ang) * 25;
                }
            });
        }

        let bossAlive = false;
        let bossSpawnedInWave = false;

        function spawnEnemy() {
            const a = Math.random() * Math.PI * 2;
            const typeKey = getEnemyType();

            // NÃO deixa spawnar mais de um boss
            if (typeKey === 'boss' && bossAlive) return;

            const type = enemyTypes[typeKey];

            if (typeKey === 'boss') {
                if (bossAlive) return; // Checa
                bossAlive = true;      // Bloqueia NA HORA
            }

            const baseHp = waveEnemyHP;
            const baseSpeed = 2 + wave * 0.15 + level * 0.05;

            const hitRadiusByType = {
                normal: 22,
                elite: 30,
                tank: 80,
                boss: 50
            };

            enemies.push({
                x: camera.x + Math.cos(a) * 1000,
                y: camera.y + Math.sin(a) * 1000,

                hp: baseHp * type.hpMult,
                maxHp: baseHp * type.hpMult,

                r: hitRadiusByType[typeKey],
                s: baseSpeed * type.speedMult,

                hitTimer: 0,
                hpBarTimer: 0,

                angle: 0,

                orbitAngle: Math.random() * Math.PI * 2,
                fireCd: 0,

                type: typeKey,
                sprite: enemySprites[type.sprite],

                // ===== BOSS STATE =====
                state: typeKey === 'boss' ? 'intro' : 'normal',
                introTimer: typeKey === 'boss' ? 60 : 0, // 3 segundos (60fps)

                type: typeKey,
                sprite: enemySprites[type.sprite]
            });
        }



        function update() {
            // =============================
            // MOVIMENTO DO PLAYER
            // =============================
            if (keys['w']) p1.y -= upgrades.moveSpeed;
            if (keys['s']) p1.y += upgrades.moveSpeed;
            if (keys['a']) p1.x -= upgrades.moveSpeed;
            if (keys['d']) p1.x += upgrades.moveSpeed;

            camera.x += (p1.x - camera.x) * camera.lerp;
            camera.y += (p1.y - camera.y) * camera.lerp;

            const worldMouseX = mouse.x - (canvas.width / 2) + camera.x;
            const worldMouseY = mouse.y - (canvas.height / 2) + camera.y;
            p1.angle = Math.atan2(worldMouseY - p1.y, worldMouseX - p1.x);

            // =============================
            // TIROS DO PLAYER
            // =============================
            if (p1.cd > 0) p1.cd--;
            else {
                bullets.push({
                    x: p1.x, y: p1.y,
                    vx: Math.cos(p1.angle) * 12,
                    vy: Math.sin(p1.angle) * 12,
                    angle: p1.angle + Math.PI / 2,
                    type: 'medium',
                    damage: upgrades.damage * 1.2
                });
                p1.cd = upgrades.fireRate;
            }

            // =============================
            // LÓGICA DE TIRO E ESTADO DOS INIMIGOS
            // =============================
            enemies.forEach(e => {
                if (e.type === 'boss') {
                    if (e.state === 'intro') {
                        e.introTimer--;
                        if (e.introTimer <= 0) {
                            e.state = 'combat';
                            e.fireCd = 60;
                        }
                        return; // Sai desta iteração, boss não atira na intro
                    }
                    // Se for boss e estiver em combate, chama a IA dele
                    bossAI(e);
                }
            });

            // Agora o loop das balas dos inimigos (que já estava quase certo)
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                b.x += b.vx;
                b.y += b.vy;
                b.life--;

                const dx = b.x - p1.x;
                const dy = b.y - p1.y;
                if (dx * dx + dy * dy < 30 * 30) {
                    hp -= 15;
                    updateHUD();
                    enemyBullets.splice(i, 1);
                    if (hp <= 0) gameState = 'gameover';
                    continue;
                }

                if (b.life <= 0 || Math.abs(b.x - camera.x) > 1300 || Math.abs(b.y - camera.y) > 1000) {
                    enemyBullets.splice(i, 1);
                }
            }
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];

                b.x += b.vx;
                b.y += b.vy;
                b.life--;

                // colisão com player
                const dx = b.x - p1.x;
                const dy = b.y - p1.y;
                if (dx * dx + dy * dy < 30 * 30) {
                    hp -= 15;
                    updateHUD();
                    enemyBullets.splice(i, 1);
                    if (hp <= 0) gameState = 'gameover';
                    continue;
                }

                // remove se acabar a vida ou sair da tela
                if (
                    b.life <= 0 ||
                    Math.abs(b.x - camera.x) > 1300 ||
                    Math.abs(b.y - camera.y) > 1000
                ) {
                    enemyBullets.splice(i, 1);
                }
            }


            // =============================
            // LASER
            // =============================
            if (upgrades.laserGun) {
                if (p1.laserCd > 0) p1.laserCd--;
                else if (enemies.length > 0) {
                    let target = enemies[0];
                    const ang = Math.atan2(target.y - p1.y, target.x - p1.x);
                    bullets.push({
                        x: p1.x, y: p1.y,
                        vx: Math.cos(ang) * 18,
                        vy: Math.sin(ang) * 18,
                        angle: ang + Math.PI / 2,
                        type: 'small',
                        damage: upgrades.damage * upgrades.laserDamageMult
                    });
                    p1.laserCd = upgrades.laserFireRate;
                }
            }

            // =============================
            // PLASMA
            // =============================
            if (upgrades.plasmaCannon) {
                if (upgrades.plasmaCd > 0) upgrades.plasmaCd--;
                else if (enemies.length > 0) {
                    let target = enemies[Math.floor(Math.random() * Math.min(enemies.length, 5))];
                    const ang = Math.atan2(target.y - p1.y, target.x - p1.x);
                    bullets.push({
                        x: p1.x, y: p1.y,
                        vx: Math.cos(ang) * 7,
                        vy: Math.sin(ang) * 7,
                        angle: ang + Math.PI / 2,
                        type: 'large',
                        damage: upgrades.damage * upgrades.plasmaDamageMult
                    });
                    upgrades.plasmaCd = 110;
                }
            }

            // =============================
            // PARTÍCULAS / EXPLOSÕES
            // =============================
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                return p.life > 0;
            });

            explosions = explosions.filter(ex => {
                ex.r += 7;
                ex.alpha -= 0.035;
                return ex.alpha > 0;
            });

            // =============================
            // SISTEMA DE HORDAS (SPAWN)
            // =============================
            if (spawnCooldown <= 0 && enemiesToSpawn > 0) {
                spawnEnemy();
                enemiesToSpawn--;
                // Mude a linha abaixo:
                spawnCooldown = waveSpawnInterval;
            } else {
                spawnCooldown--;
            }

            // =====================================================
            // ❌ NÃO DEFINIR FUNÇÃO DENTRO DO update()
            // ❌ spawnEnemy() DEVE FICAR FORA (escopo global)
            // =====================================================

            // =============================
            // MOVIMENTO DAS BALAS E DANO
            // =============================
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;

                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dx = b.x - e.x;
                    const dy = b.y - e.y;

                    if (dx * dx + dy * dy < (e.r + 15) * (e.r + 15)) {
                        // Boss invencível na intro
                        if (e.type === 'boss' && e.state === 'intro') {
                            hit = true;
                            break;
                        }
                        e.hp -= b.damage;
                        e.hitTimer = 3;
                        e.hpBarTimer = 90;
                        hit = true;
                        break;
                    }
                }

                if (hit || Math.abs(b.x - camera.x) > 1200 || Math.abs(b.y - camera.y) > 900) {
                    // Se a bala atingiu um inimigo e é do tipo plasma, gera a explosão
                    if (hit && b.type === 'large') {
                        triggerExplosion(b.x, b.y, 120, b.damage);
                    }

                    bullets.splice(i, 1);
                }
            }

            // =============================
            // MOVIMENTO + IA DOS INIMIGOS
            // =============================
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];

                // --- 1. ATUALIZAR TIMERS DE DANO (Para ele parar de piscar/ficar transparente) ---
                if (e.hitTimer > 0) e.hitTimer--;
                if (e.hpBarTimer > 0) e.hpBarTimer--;



                // --- 2. LÓGICA DO BOSS ---
                if (e.type === 'boss') {
                    if (e.state === 'intro') {
                        e.introTimer--;
                        if (e.introTimer <= 0) e.state = 'combat';
                    }

                    const dx = p1.x - e.x;
                    const dy = p1.y - e.y;
                    const dist = Math.hypot(dx, dy);
                    const desiredDist = 260;
                    const speed = e.s;

                    // Movimento de aproximação/afastamento do Boss
                    if (dist > desiredDist + 40) {
                        e.x += (dx / dist) * speed;
                        e.y += (dy / dist) * speed;
                    } else if (dist < desiredDist - 40) {
                        e.x -= (dx / dist) * speed;
                        e.y -= (dy / dist) * speed;
                    }
                    e.angle = Math.atan2(dy, dx);

                } else {
                    // --- 3. MOVIMENTO INIMIGOS NORMAIS ---
                    const ang = Math.atan2(p1.y - e.y, p1.x - e.x);

                    // Só se movem se NÃO estiverem sob efeito de knockback forte (opcional)
                    // Ou simplesmente somamos o movimento normal:
                    e.x += Math.cos(ang) * e.s;
                    e.y += Math.sin(ang) * e.s;
                    e.angle = ang;
                }

                // --- 4. APLICAR EMPURRÃO (KNOCKBACK) ---
                // Se o hitTimer for alto, ele recebe uma força extra para trás
                if (e.hitTimer > 0) {
                    const knockbackAng = Math.atan2(e.y - p1.y, e.x - p1.x);
                    e.x += Math.cos(knockbackAng) * 4; // Força do empurrão
                    e.y += Math.sin(knockbackAng) * 4;
                }

                // --- LÓGICA DE SEPARAÇÃO (Para não ficarem um sobre o outro) ---
                for (let j = 0; j < enemies.length; j++) {
                    const outro = enemies[j];
                    if (e === outro) continue; // Não comparar o inimigo com ele mesmo

                    const dx = e.x - outro.x;
                    const dy = e.y - outro.y;
                    const distanciaSq = dx * dx + dy * dy;
                    const distanciaMinima = e.r + outro.r; // Soma dos raios

                    // Se a distância for menor que a soma dos raios (estão sobrepostos)
                    if (distanciaSq < distanciaMinima * distanciaMinima) {
                        const dist = Math.sqrt(distanciaSq) || 1; // Evita divisão por zero
                        const forca = (distanciaMinima - dist) / 2; // O quanto eles devem se afastar

                        // Calcula o ângulo da repulsão
                        const angulo = Math.atan2(dy, dx);

                        // Move levemente para fora
                        const moveX = Math.cos(angulo) * 0.5; // 0.5 é a intensidade da repulsão
                        const moveY = Math.sin(angulo) * 0.5;

                        e.x += moveX;
                        e.y += moveY;
                        outro.x -= moveX;
                        outro.y -= moveY;
                    }
                }
            }

            // =============================
            // MORTE / DANO AO PLAYER
            // =============================
            enemies = enemies.filter(e => {
                if (e.hp <= 0) {
                    let xpValue = 20 + (level * 2); // Valor padrão
                    let isBoss = (e.type === 'boss');

                    if (isBoss) {
                        bossAlive = false;
                        score += 1000; // Pontuação bônus do Boss
                        // Loop exclusivo para os vários cristais do Boss
                        updateHUD();
                        for (let i = 0; i < 10; i++) {
                            loot.push({
                                x: e.x + (Math.random() - 0.5) * 60,
                                y: e.y + (Math.random() - 0.5) * 60,
                                value: 50 // Cada um vale 50
                            });
                        }
                    } else {
                        // Lógica para inimigos que soltam apenas UM cristal
                        if (e.type === 'elite') {
                            xpValue = 60; // Elite vale mais
                        } else if (e.type === 'tank') {
                            xpValue = 100; // Tank vale ainda mais
                        }

                        loot.push({ x: e.x, y: e.y, value: xpValue });
                        score += 20;
                    }

                    updateHUD();

                    // Partículas de explosão (comum a todos)
                    for (let k = 0; k < 12; k++) {
                        createParticle(
                            e.x, e.y, '#fff', 4,
                            (Math.random() - 0.5) * 6,
                            (Math.random() - 0.5) * 6,
                            12
                        );
                    }

                    return false; // Remove o inimigo da lista
                }

                const distSq = (p1.x - e.x) ** 2 + (p1.y - e.y) ** 2;
                if (distSq < 42 * 42) {
                    hp -= 8;
                    updateHUD();
                    if (hp <= 0) gameState = 'gameover';
                    return false;
                }
                return true;
            });

            // =============================
            // LOOT
            // =============================
            loot = loot.filter(l => {
                const distSq = (p1.x - l.x) ** 2 + (p1.y - l.y) ** 2;
                if (distSq < upgrades.magnetRange * upgrades.magnetRange) {
                    l.x += (p1.x - l.x) * 0.12;
                    l.y += (p1.y - l.y) * 0.12;
                }
                if (distSq < 28 * 28) {
                    xp += l.value;
                    updateHUD();
                    if (xp >= nextLevelXp) levelUp();
                    return false;
                }
                return distSq <= 3500 * 3500;
            });

            // =============================
            // FIM DA HORDA
            // =============================
            if (waveInProgress && enemies.length === 0 && enemiesToSpawn === 0) {
                waveInProgress = false;
                score += wave * 50;
                updateHUD();
                wave++;
                startWave();
            }
        }
        //====================================
        // FUNÇÃO PARA CRIAR A EXPLOSÃO (LÓGICA + VISUAL)
        //====================================

        function triggerExplosion(x, y, radius, damage) {
            // 1. Lógica de Dano em Área
            enemies.forEach(e => {
                const dx = e.x - x;
                const dy = e.y - y;
                const distSq = dx * dx + dy * dy;
                if (distSq < (radius + e.r) * (radius + e.r)) {
                    e.hp -= damage;
                    e.hitTimer = 10;
                }
            });

            // 2. Adicionar a animação de Sprite à lista
            explosionAnimations.push({
                x: x,
                y: y,
                currentFrame: 0,
                timer: 0,
                frameSpeed: 4, // Quantos frames de jogo para mudar o sprite
                scale: radius / 30 // Ajusta o tamanho do sprite ao raio da explosão
            });
        }

        function bossAI(e) {
            const dx = p1.x - e.x;
            const dy = p1.y - e.y;

            const dist = Math.sqrt(dx * dx + dy * dy);
            const angleToPlayer = Math.atan2(dy, dx);

            // ===== MIRAR SEMPRE NO PLAYER =====
            e.angle = angleToPlayer;

            // ===== MOVIMENTO DO BOSS =====
            let moveAngle = angleToPlayer;

            // perto demais → se afasta
            if (dist < BOSS_MIN_DIST) {
                moveAngle += Math.PI;
            }
            // longe demais → se aproxima
            else if (dist > BOSS_MAX_DIST) {
                // mantém moveAngle normal
            }
            // distância ideal → orbita
            else {
                e.orbitAngle += 0.01;
                moveAngle = angleToPlayer + Math.PI / 0.02;
            }

            const speed = e.s * 0.8; // boss mais pesado

            e.x += Math.cos(moveAngle) * speed;
            e.y += Math.sin(moveAngle) * speed;

            // ===== TIRO DO BOSS =====
            if (e.fireCd > 0) {
                e.fireCd--;
            } else {
                enemyBullets.push({
                    x: e.x,
                    y: e.y,
                    vx: Math.cos(angleToPlayer) * 20,
                    vy: Math.sin(angleToPlayer) * 20,
                    life: 180
                });

                e.fireCd = 10; // cadência de tiro
            }
        }


        const BOSS_MIN_DIST = 600; // perto demais → afasta
        const BOSS_MAX_DIST = 860; // longe demabosis → aproxima


        function startWave() {
            waveInProgress = true;
            bossSpawnedInWave = false; // Resetamos o controle aqui

            // Se for wave de boss, apenas 1 inimigo (o próprio boss)
            if (wave % 10 === 0) {
                enemiesToSpawn = 1;
                waveEnemyHP = 100 + (wave * 5); // Opcional: HP customizado para o Boss solitário
            } else {
                // Lógica normal para as outras ondas
                waveEnemyHP = 3 + (wave * 1.5) + (level * 1.0);
                enemiesToSpawn = 12 + wave * 5 + Math.floor(level * 1.5);
            }

            waveSpawnInterval = Math.max(30, 40 - (wave * 3));
            spawnCooldown = 0;
            showWaveBanner();
        }

        function showWaveBanner() {
            waveBanner.active = true;
            waveBanner.timer = 0;
            waveBanner.text = `⚠ PROTOCOLO DE DEFESA: HORDA ${wave} ⚠`;
        }



        function levelUp() {
            gameState = 'paused';
            xp = 0;
            level++;
            nextLevelXp = 100 + (level * 40) + Math.floor(level ** 1.8);
            updateHUD();

            const box = document.getElementById('cardsBox');
            box.innerHTML = '';

            // Lista de opções com IDs correspondentes ao objeto activeUpgrades
            const ops = [
                {
                    id: 'laser',
                    t: "Protocolo Laser",
                    d: "Ativa/Melhora o laser: +50% de dano e tiro mais rápido.",
                    a: () => {
                        upgrades.laserGun = true;
                        upgrades.laserDamageMult += 0.50;
                        upgrades.laserFireRate = Math.max(4, upgrades.laserFireRate * 0.82);
                        activeUpgrades.laser++; // Incrementa contador
                    }
                },
                {
                    id: 'plasma',
                    t: "Canhão Pesado",
                    d: "Ativa/Melhora o plasma: +50% de dano de explosão.",
                    a: () => {
                        upgrades.plasmaCannon = true;
                        upgrades.plasmaDamageMult += 0.5;
                        activeUpgrades.plasma++; // Incrementa contador
                    }
                },
                {
                    id: 'speed',
                    t: "Impulso de Manobra",
                    d: "Aumenta a velocidade de movimento em +1.0.",
                    a: () => {
                        upgrades.moveSpeed += 1.0;
                        activeUpgrades.speed++; // Incrementa contador
                    }
                },
                {
                    id: 'magnet',
                    t: "Imã de Detritos",
                    d: "Alcance de coleta de XP aumentado em +50.",
                    a: () => {
                        upgrades.magnetRange += 50;
                        activeUpgrades.magnet++; // Incrementa contador
                    }
                },
                {
                    id: 'heal',
                    t: "Reparo de Casco",
                    d: "Restaura 50% da integridade total do núcleo.",
                    a: () => {
                        hp = Math.min(100, hp + 50);
                        updateHUD();
                    }
                },
                {
                    id: 'fireRate',
                    t: "Célula de Recarga",
                    d: "Reduz o intervalo do tiro manual (Metralhadora).",
                    a: () => {
                        upgrades.fireRate = Math.max(4, upgrades.fireRate - 2.5);
                        activeUpgrades.fireRate++; // Incrementa contador
                    }
                },
                {
                    id: 'damage',
                    t: "Módulo de Potência",
                    d: "Dano de todas as armas aumentado em +50%.",
                    a: () => {
                        upgrades.damage += 0.50;
                        activeUpgrades.damage++; // Incrementa contador
                    }
                }
            ];

            // Sorteia 3 opções e cria os cards
            ops.sort(() => Math.random() - 0.5).slice(0, 3).forEach(o => {
                const d = document.createElement('div');
                d.className = 'card';
                d.innerHTML = `<h3>${o.t}</h3><p>${o.d}</p>`;
                d.onclick = () => {
                    o.a();
                    document.getElementById('levelUpMenu').style.display = 'none';
                    gameState = 'playing';
                    updateHUD();
                    renderUpgradeHUD();
                };

                box.appendChild(d);
            });
            document.getElementById('levelUpMenu').style.display = 'flex';
        }


        function toS(x, y) {
            return {
                x: x - camera.x + canvas.width / 2,
                y: y - camera.y + canvas.height / 2
            };
        }
        function draw() {
            // ctx.fillStyle = bgPattern || '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            ctx.globalAlpha = 1;

            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            // ... desenha inimigos, balas, jogador, etc ...
            ctx.restore();

            const cx = canvas.width / 2; const cy = canvas.height / 2;
            // const toS = (x, y) => ({ x: x - bosscamera.x + cx, y: y - camera.y + cy });

            particles.forEach(p => {
                const s = toS(p.x, p.y);
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.fillRect(s.x, s.y, p.size, p.size);
            });
            ctx.globalAlpha = 1.0;

            explosions.forEach(ex => {
                const p = toS(ex.x, ex.y);
                ctx.beginPath();
                ctx.fillStyle = `rgba(255, 120, 0, ${ex.alpha * 0.6})`;
                ctx.arc(p.x, p.y, ex.r, 0, Math.PI * 2);
                ctx.fill();
            });

            bullets.forEach(b => {
                const p = toS(b.x, b.y);

                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(b.angle);

                if (spriteLoaded) {
                    let s, scale;

                    switch (b.type) {
                        case 'small':
                            s = bulletSmall;
                            scale = 1.5;
                            break;

                        case 'medium':
                            s = bulletMedium;
                            scale = 3.5;
                            break;

                        case 'large':
                            s = bulletLarge;
                            scale = 1.2;
                            break;
                    }

                    ctx.drawImage(
                        spriteImg,
                        s.sx, s.sy, s.sw, s.sh,
                        -(s.sw * scale) / 2,
                        -(s.sh * scale) / 2,
                        s.sw * scale,
                        s.sh * scale
                    );
                }

                ctx.restore();
            });

            // =============================
            // DESENHAR BALAS DO BOSS
            // =============================
            enemyBullets.forEach(b => {
                const p = toS(b.x, b.y);

                ctx.beginPath();
                ctx.fillStyle = '#ff3355';
                ctx.arc(p.x, p.y, 10, 0, Math.PI * 20);
                ctx.fill();
            });


            loot.forEach(l => {
                const p = toS(l.x, l.y);
                if (spriteLoaded) ctx.drawImage(spriteImg, xpSpriteDef.sx, xpSpriteDef.sy, xpSpriteDef.sw, xpSpriteDef.sh, p.x - 10, p.y - 10, 20, 20);
            });

            explosionAnimations.forEach((anim, index) => {
                const p = toS(anim.x, anim.y);
                const frame = explosionFrames[anim.currentFrame];

                ctx.drawImage(
                    spriteImg,
                    frame.sx, frame.sy, frame.sw, frame.sh, // Recorte original
                    p.x - (frame.sw * anim.scale) / 2,      // Posição X centrada usando o sw real
                    p.y - (frame.sh * anim.scale) / 2,      // Posição Y centrada usando o sh real
                    frame.sw * anim.scale,                  // Largura de destino BASEADA NO FRAME
                    frame.sh * anim.scale                   // Altura de destino BASEADA NO FRAME
                );

                // Avançar animação
                anim.timer++;
                if (anim.timer >= anim.frameSpeed) {
                    anim.timer = 0;
                    anim.currentFrame++;
                }
            });

            // Remover animações terminadas
            explosionAnimations = explosionAnimations.filter(a => a.currentFrame < explosionFrames.length);


            const pos = toS(p1.x, p1.y);
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(p1.angle + Math.PI / 2);
            if (spriteLoaded) {
                ctx.drawImage(spriteImg, shipSprite.sx, shipSprite.sy, shipSprite.sw, shipSprite.sh, -30, -40, 60, 80);
            }
            ctx.restore();

            if (gameState === 'gameover') {
                document.getElementById('finalScore').innerText = score;
                document.getElementById('gameOverScreen').style.display = 'flex';
            }

            if (waveBanner.active) {
                const t = waveBanner.timer / waveBanner.duration;

                let alpha = 1;
                if (t < 0.2) alpha = t / 0.2;           // fade in
                else if (t > 0.8) alpha = (1 - t) / 0.2; // fade out

                ctx.save();
                ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                ctx.font = 'bold 64px Segoe UI';
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 25;

                ctx.fillText(waveBanner.text, canvas.width / 2, canvas.height / 2);

                ctx.restore();

                waveBanner.timer++;
                if (waveBanner.timer >= waveBanner.duration) {
                    waveBanner.active = false;
                }
            }

            function drawBackground() {
                // Fundo sólido escuro
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                starLayers.forEach(layer => {
                    ctx.save();

                    layer.stars.forEach(s => {
                        // Movimento relativo à câmera + velocidade da camada
                        // O segredo do infinito: Math.abs(x) % largura
                        let x = (s.x - camera.x * layer.speed) % canvas.width;
                        let y = (s.y - camera.y * layer.speed) % canvas.height;

                        // Garante que o valor seja sempre positivo para não "sumir"
                        if (x < 0) x += canvas.width;
                        if (y < 0) y += canvas.height;

                        if (s.sprite && spriteLoaded) {
                            ctx.globalAlpha = s.opacity;
                            ctx.drawImage(spriteImg, s.sprite.sx, s.sprite.sy, s.sprite.sw, s.sprite.sh,
                                x, y, s.sprite.sw * 0.5, s.sprite.sh * 0.5);
                        } else {
                            ctx.fillStyle = `rgba(255, 255, 255, ${s.opacity})`;
                            ctx.beginPath();
                            ctx.arc(x, y, s.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });

                    ctx.restore();
                });
            }


            enemies.forEach(drawEnemy);
        }

        function drawEnemy(e) {
            if (!spriteLoaded) return;

            const p = toS(e.x, e.y);
            const s = e.sprite;

            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(e.angle + Math.PI / 2);

            // Flash de dano (sem piscar branco feio)
            if (e.type === 'boss' && e.state === 'intro') {
                ctx.globalAlpha = 0.2;
            }

            if (e.hitTimer > 0) ctx.globalAlpha = 0.7;

            ctx.drawImage(
                spriteImg,
                s.sx, s.sy, s.sw, s.sh,
                -s.sw,
                -s.sh,
                s.sw * 2,
                s.sh * 2
            );

            ctx.restore();
            ctx.globalAlpha = 1;

            // ===== BARRA DE VIDA =====
            if (
                (e.type === 'elite' || e.type === 'tank' || e.type === 'boss') &&
                e.hpBarTimer > 0
            ) {
                const barWidth = e.type === 'boss' ? 80 : 40;
                const barHeight = 5;
                const hpRatio = Math.max(0, e.hp / e.maxHp);
                const shake = e.hitTimer > 0 ? Math.random() * 2 : 0;

                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(
                    p.x - barWidth / 2 + shake,
                    p.y - e.r - 14,
                    barWidth,
                    barHeight
                );

                ctx.fillStyle =
                    e.type === 'boss' ? '#ff0055' :
                        e.type === 'tank' ? '#ffaa00' :
                            '#00ffff';

                ctx.fillRect(
                    p.x - barWidth / 2 + shake,
                    p.y - e.r - 14,
                    barWidth * hpRatio,
                    barHeight
                );
            }
        }

        const upgradeImages = {
            laser: new Image(),
            plasma: new Image(),
            speed: new Image(),
            magnet: new Image(),
            fireRate: new Image(),
            damage: new Image()
        };

        upgradeImages.laser.src = "icones/laser.png";
        upgradeImages.plasma.src = "icones/plasma.png";
        upgradeImages.speed.src = "icones/speedIcon.png";
        upgradeImages.magnet.src = "icones/magnet.png";
        upgradeImages.fireRate.src = "icones/firerate.png";
        upgradeImages.damage.src = "icones/damage.png";



        function renderPauseUpgrades() {
            const container = document.getElementById('pauseUpgradesContainer');
            if (!container) return;

            container.innerHTML = '';

            // Pegamos os upgrades que você JÁ TEM (activeUpgrades)
            // Usamos Object.entries para transformar o objeto em uma lista que podemos percorrer
            Object.entries(activeUpgrades).forEach(([id, quantidade]) => {
                // Só mostra se você tiver pelo menos 1 nível desse upgrade
                if (quantidade > 0) {
                    const card = document.createElement('div');
                    card.className = 'upgrade-card';

                    const img = document.createElement('img');
                    // Busca a imagem no objeto global que você já definiu
                    if (upgradeImages[id]) {
                        img.src = upgradeImages[id].src;
                    }

                    const title = document.createElement('h3');
                    // Mapeamento simples de ID para Nome legível
                    const nomes = {
                        laser: "Laser",
                        plasma: "Plasma",
                        speed: "Velocidade",
                        magnet: "Ímã",
                        fireRate: "Cadência",
                        damage: "Dano"
                    };
                    title.textContent = nomes[id] || id;

                    const count = document.createElement('span');
                    count.className = 'pause-upgrade-count';
                    count.textContent = 'Nível: ' + quantidade;

                    card.appendChild(img);
                    card.appendChild(title);
                    card.appendChild(count);

                    container.appendChild(card);
                }
            });

            // Se não tiver nenhum upgrade ainda
            if (container.innerHTML === '') {
                container.innerHTML = '<p style="color: #444;">Nenhum sistema instalado ainda.</p>';
            }
        }
        //INIMIGOS DEFINIDOS!

        // DEFINIR TIPOS DE INIMIGO (CONFIGURAÇÃO)

        const enemyTypes = {
            normal: {
                hpMult: 1,
                speedMult: 1,
                sprite: 'normal'
            },
            elite: {
                hpMult: 2,
                speedMult: 1.1,
                sprite: 'elite'
            },
            tank: {
                hpMult: 4,
                speedMult: 0.6,
                sprite: 'tank'
            },
            boss: {
                hpMult: 70,
                speedMult: 3,
                sprite: 'boss'
            }
        };


        // ESCOLHER O TIPO BASEADO NA HORDA

        // Função que decide qual inimigo nasce:
        function getEnemyType() {
            // Só retorna boss se for a wave certa E se ainda não spawnou um NESTA wave
            if (wave % 10 === 0) {
                return 'boss';
            }

            // Inimigos normais para as outras waves
            if (wave > 5 && Math.random() < 0.50) return 'elite';
            if (wave > 8 && Math.random() < 0.25) return 'tank';
            return 'normal';
        }


        function renderUpgradeHUD() {
            const hud = document.getElementById('upgradeHUD');
            hud.innerHTML = '';

            for (const [key, count] of Object.entries(activeUpgrades)) {
                if (count <= 0) continue;

                const icon = document.createElement('div');
                icon.className = 'upgrade-icon';

                const img = document.createElement('img');
                img.src = upgradeImages[key].src;

                const qty = document.createElement('span');
                qty.className = 'upgrade-count';
                qty.textContent = 'x' + count;

                icon.appendChild(img);
                icon.appendChild(qty);
                hud.appendChild(icon);
            }
        }

        function gameLoop() {
            if (gameState === 'playing') {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
        resize();
    </script>
</body>

</html>